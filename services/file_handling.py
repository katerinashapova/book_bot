#модуль для подготовки книги, чтобы боту было удобно с ней работать.
#Для того, чтобы было удобно работать с книгой -  нужно преобразовать текстовый файл книги в словарь,
#  где ключами будут номера страниц, а значениями - тексты этих страниц.
import os
import sys

BOOK_PATH = 'book/book.txt'
PAGE_SIZE = 1050

book: dict[int, str] = {}


# Функция, возвращающая строку с текстом страницы и ее размер
def _get_part_text(text: str, start: int, page_size: int) -> tuple[str, int]:
    # Определим набор знаков препинания
    punctuation_marks = {',', '.', '!', ':', ';', '?'}
#Переменная counter используется для того, чтобы отслеживать, сколько символов нужно
# убрать с конца текста, если он не заканчивается на знаке препинания
    counter = 0
#Этот блок проверяет, достаточно ли текста для выделения страницы длиной page_size.
# Если текст короче, чем заданный размер страницы, программа корректирует длину
# страницы так, чтобы она не выходила за пределы текста.
    if len(text) < start + page_size:
        page_size = len(text) - start
        text = text[start:start + page_size]
        #Этот блок проверяет случай, когда строка после стартовой позиции и длины страницы заканчивается на точке (например, многоточие).
        # Если перед точкой идет другой знак препинания (например, ..., ?!),
        #  текст обрезается на два символа меньше, чтобы избежать разрыва многоточия или последовательности.
        # Также уменьшается page_size.
    else:

        if text[start + page_size] == '.' and text[start + page_size -1] in punctuation_marks:
            text = text[start:start + page_size - 2]
            page_size -= 2
            ##Если не срабатывает условие с многоточием или последовательностью знаков препинания,
        # текст просто обрезается по границе page_size.
        else:
            text = text[start:start + page_size]
#Этот цикл проходит по обрезанному тексту с конца и ищет последний знак препинания. Как только знак найден, цикл останавливается (используется break).
#  Если в конце текста нет знака препинания, переменная counter подсчитывает количество символов,
# которые нужно убрать с конца текста (чтобы текст корректно заканчивался).
        for i in range(page_size - 1, 0, -1):
            if text[i] in punctuation_marks:
                break
            counter = page_size - i
            #Здесь текст обрезается до нужного размера, учитывая найденный знак препинания.
            # Если не нашлось подходящего знака препинания, убираются символы, соответствующие значению counter.
            # Длина итогового текста также обновляется с учетом этого.
    page_text = text[:page_size - counter]
    size = page_size - counter

    # Возвращаем текст страницы и её длину
    return page_text, size


# Функция, формирующая словарь книги
def prepare_book(path: str) -> None:

    with open(file = path, mode = 'r', encoding = 'utf-8') as f:
        content = f.read()
    start = 0
    counter = 1

    while start < len(content):
        page_text, size = _get_part_text(content, start, PAGE_SIZE)
        start += size

        book[counter] = page_text.lstrip()
        counter += 1


# Вызов функции prepare_book для подготовки книги из текстового файла
prepare_book(os.path.join(sys.path[0], os.path.normpath(BOOK_PATH)))